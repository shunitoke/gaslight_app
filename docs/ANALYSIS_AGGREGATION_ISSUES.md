# Проблемы в логике склейки ответов LLM и формирования отчета

## Критические проблемы

### 1. Дублирование обработки `overviewSummary`
**Местоположение:** строки 932-964 и 1303-1324

**Проблема:** Логика извлечения строки из объекта `overviewSummary` дублируется в двух местах:
- При сборе из чанков (строки 934-948)
- При финальной обработке (строки 1308-1324)

**Решение:** Вынести в отдельную функцию `extractOverviewSummaryText()`

### 2. Нелогичная агрегация enhanced analysis полей
**Местоположение:** строки 892-930

**Проблема:** Для большинства enhanced analysis полей берется только **первое непустое значение** из любого чанка:
```typescript
if (parsed.communicationStats && !aggregatedCommunicationStats) {
  aggregatedCommunicationStats = parsed.communicationStats;
}
```

Это нелогично, потому что:
- `contradictions` правильно агрегируются через `push(...)`
- `communicationStats`, `promiseTracking` и другие должны агрегироваться, а не браться из первого чанка
- Разные чанки могут содержать разные части данных, которые нужно объединить

**Решение:** Правильно агрегировать данные:
- `communicationStats` - объединять статистику из всех чанков
- `promiseTracking` - суммировать обещания из всех чанков
- `redFlagCounts` - суммировать флаги
- `frameworkDiagnosis` - объединять данные из всех чанков

### 3. Избыточная очистка `overviewSummary` от JSON артефактов
**Местоположение:** строки 952-959

**Проблема:** Множественные regex замены для удаления JSON артефактов:
```typescript
cleanSummary = cleanSummary.replace(/"gaslightingRiskScore"\s*:\s*[0-9.]+/gi, '');
cleanSummary = cleanSummary.replace(/"conflictIntensityScore"\s*:\s*[0-9.]+/gi, '');
// ... еще 5 замен
```

**Решение:** Использовать один regex для удаления всех JSON полей:
```typescript
cleanSummary = cleanSummary.replace(/"\w+"\s*:\s*[0-9.]+/gi, ''); // Удаляет все числовые поля
cleanSummary = cleanSummary.replace(/"sections"\s*:\s*\[/gi, '');
```

### 4. Функция `normalizeSectionId` определена внутри цикла
**Местоположение:** строки 1088-1140

**Проблема:** Функция `normalizeSectionId` определяется внутри основного цикла обработки, хотя используется только один раз после цикла.

**Решение:** Вынести функцию выше, перед циклом обработки чанков.

### 5. Final holistic analysis может перезаписать хорошие результаты
**Местоположение:** строки 1203-1296

**Проблема:** Если `bestOverview` уже хороший (длинный, без ошибок), делается дополнительный запрос к LLM, который может:
- Ухудшить качество (LLM может сократить или упростить)
- Увеличить время и стоимость
- Потенциально вернуть JSON вместо текста

**Решение:** Добавить проверку качества `bestOverview` перед вызовом final analysis:
- Если длина > 200 символов и нет ошибок - пропустить final analysis
- Или сделать final analysis опциональным через флаг

### 6. Нелогичное усреднение scores из чанков
**Местоположение:** строки 886-890, 1331-1334

**Проблема:** Scores усредняются из всех чанков:
```typescript
gaslightingScore += parsed.gaslightingRiskScore || 0;
// ...
gaslightingRiskScore: chunkCount > 0 ? gaslightingScore / chunkCount : 0,
```

Это может быть неверно, потому что:
- Каждый чанк анализирует только часть разговора
- Если конфликт был только в начале, а потом все успокоилось, усреднение даст средний результат
- Лучше было бы взять максимальное значение или взвешенное среднее

**Решение:** Рассмотреть альтернативные подходы:
- Взять максимальное значение для негативных метрик (gaslighting, conflict)
- Взять среднее для позитивных метрик (supportiveness)
- Или использовать взвешенное среднее по количеству сообщений в чанке

### 7. Обработка `overviewSummary` как объекта дублируется
**Местоположение:** строки 934-948 и 1308-1324

**Проблема:** Одинаковая логика проверки и извлечения строки из объекта повторяется дважды.

**Решение:** Вынести в функцию `ensureStringOverviewSummary(value: any): string`

## Средние проблемы

### 8. Избыточное логирование
**Местоположение:** Множественные места

**Проблема:** Слишком много детального логирования на каждом этапе, что может замедлять работу.

**Решение:** Оставить только критическое логирование, остальное сделать debug-уровнем.

### 9. Неэффективная очистка памяти
**Местоположение:** строки 1070-1075

**Проблема:** Попытка очистки памяти через `(batchResults as any).parsed = null` и `(batchResults as any).length = 0` неэффективна.

**Решение:** Просто не хранить ссылки на большие объекты, позволить GC сделать свою работу.

## Рекомендации по рефакторингу

1. **Вынести вспомогательные функции:**
   - `extractOverviewSummaryText(value: any): string`
   - `cleanOverviewSummaryFromJson(text: string): string`
   - `normalizeSectionId(id: string, title: string): string`
   - `aggregateEnhancedAnalysisFields(...)`

2. **Упростить агрегацию enhanced analysis:**
   - Создать отдельную функцию для агрегации каждого типа данных
   - Правильно объединять данные из всех чанков

3. **Оптимизировать final holistic analysis:**
   - Добавить проверку качества перед вызовом
   - Сделать опциональным

4. **Улучшить агрегацию scores:**
   - Использовать более умную логику вместо простого усреднения


