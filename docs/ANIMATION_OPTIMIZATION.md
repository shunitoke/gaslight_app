# Оптимизация Ripple и других анимаций

## Реализованные оптимизации

### 1. **Page Visibility API** ✅
- Анимации автоматически останавливаются при смене вкладки
- Экономит CPU/GPU ресурсы когда пользователь не смотрит на страницу
- Реализовано через `document.visibilitychange` в `AnimationContext`

### 1.5. **Conditional Rendering by Route** ✅
- BackgroundAnimation рендерится только на главной странице (`/`)
- Автоматически отключается на `/admin`, `/analysis`, `/terms` и других страницах
- Экономит GPU ресурсы на страницах, где анимации не нужны
- Реализовано через `ConditionalBackgroundAnimation` компонент с `usePathname`

### 2. **Отключение при импорте/анализе** ✅
- Ripple и blob анимации выключаются при `uploading` или `analyzing`
- Освобождает ресурсы для более важных операций
- Автоматически включаются обратно после завершения

### 3. **Условный рендеринг Ripple** ✅
- Ripple компоненты полностью удаляются из DOM когда не нужны
- Экономит память (не хранит DOM элементы)
- Более эффективно чем просто скрытие через CSS

### 4. **CSS animation-play-state для Blob** ✅
- Blob анимации паузируются через `animation-play-state: paused`
- Не пересоздаются в DOM, просто останавливаются
- Быстрое переключение без перерисовки

### 5. **prefers-reduced-motion** ✅
- Уважает системные настройки пользователя
- Автоматически отключает анимации если пользователь предпочитает уменьшенную анимацию
- Улучшает доступность

### 6. **Оптимизация will-change** ✅
- `willChange` устанавливается в `auto` когда анимации паузированы
- Уменьшает нагрузку на GPU когда анимации не активны

## Дополнительные варианты оптимизации (можно добавить в будущем)

### 7. **Intersection Observer**
```typescript
// Выключать анимации когда компонент не виден в viewport
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (!entry.isIntersecting) {
      // Паузить анимации
    }
  });
});
```

### 8. **Lazy Loading анимаций**
- Загружать ripple только после первого взаимодействия пользователя
- Или после загрузки основного контента
- Уменьшает начальную нагрузку

### 9. **Throttle/Debounce для сложных анимаций**
- Ограничить частоту обновлений анимаций
- Полезно для анимаций, которые реагируют на скролл или движение мыши

### 10. **Уменьшение количества элементов**
- Динамически уменьшать `numCircles` на слабых устройствах
- Определять производительность через `navigator.hardwareConcurrency` или `Device Memory API`

### 11. **CSS Containment**
```css
.ripple-container {
  contain: layout style paint;
}
```
- Изолирует область перерисовки
- Улучшает производительность

### 12. **RequestAnimationFrame для сложных вычислений**
- Использовать RAF вместо CSS анимаций для более точного контроля
- Можно паузить/возобновлять более гибко

### 13. **Web Workers для вычислений**
- Выносить тяжелые вычисления (например, генерация позиций) в Web Worker
- Не блокирует главный поток

### 14. **Условная загрузка на мобильных**
- Полностью отключать ripple на мобильных устройствах
- Уже частично реализовано через `hidden md:block`

### 15. **Memory Management**
- Периодически проверять использование памяти
- Автоматически упрощать анимации при нехватке памяти

## Текущая архитектура

```
ConditionalBackgroundAnimation (route-based rendering)
  └── usePathname() проверяет маршрут
      ├── pathname === '/' → рендерит BackgroundAnimation
      └── иначе → возвращает null (экономия GPU)

AnimationContext (глобальное состояние)
  ├── isPageVisible (Page Visibility API)
  ├── isProcessing (uploading/analyzing)
  ├── prefersReducedMotion (системные настройки)
  └── animationsEnabled (комбинированная логика)

BackgroundAnimation
  ├── Ripple (условный рендеринг - удаляется из DOM)
  └── Blob (CSS animation-play-state - паузится)

page.tsx
  └── useEffect отслеживает uploading/analyzing → setProcessing()
```

## Метрики производительности

Для мониторинга можно добавить:
- FPS метрики через `requestAnimationFrame`
- Memory usage через `performance.memory` (Chrome)
- CPU usage через Performance API

## Рекомендации

1. **Приоритет**: Page Visibility > Processing State > Reduced Motion
2. **Стратегия**: Удаление из DOM для Ripple, пауза через CSS для Blob
3. **Мониторинг**: Следить за производительностью на слабых устройствах
4. **Тестирование**: Проверить на мобильных устройствах и старых браузерах

